/**
 * ## Webブラウザ上のJavaScript
 * ## 15.1 Webプログラミングの基礎
 * <script>タグ内にjavascriptで処理を書くことができる。
 * ```
 * <script>
      // 現在時刻を表示する関数を定義する。
      function displayTime() {
        let clock = document.querySelector("#clock"); // id="clock"の要素を取得する。
        let now = new Date(); // 現在時刻を取得する。
        clock.textContent = now.toLocaleTimeString(); // 要素中に時刻を表示する。
      }
      displayTime(); // 時刻をすぐに表示する。
      setInterval(displayTime, 1000); // そして、毎秒更新する。
    </script>
 * ```
 * 通常は、`<script src="scripts/digital_clock.js"></script>`のように指定する。
 * srcで指定するパスは相対パスでも絶対パスでもOK。読み込みは１度だけ。
 * 
 * ### 15.1.1.1 モジュール
 * モジュールをバンドリングツールで1つのJavaScriptの非モジュールファイルにまとめていない場合は、
 * type="module"を<script>タグで指定して、import/exportできるようにする必要がある。
 * 
 * ### 15.1.1.3 スクリプトの非同期実行と遅延実行
 * 過去のWebブラウザではscript中でコンテンツ作成するのに`document.write`が使用されていた。
 * scriptタグ内でHTMLが出力される可能性があるため、HTMLパーサーはscriptタグを見つけるとドキュメントの解釈や描画を中断してscriptタグの実行を待つ。
 * scriptタグによる同期実行（ブロッキング）を防ぐ方法として、defer属性とasync属性を指定する方法がある。
 * ※defer属性もasync属性もブラウザに対してdocument.writeを使わずHTMLを出力しないことを通知する。
 * - defer属性
 * ドキュメントが読み込まれるまで、scriptを遅延
 * - async属性
 * ドキュメント読み込み中にscriptも非同期で実行
 * `type="module"`属性を持つスクリプトはデフォルトではdefer属性をつけられたスクリプト同様、ドキュメントの読み込み後に実行される。
 * asyncを付与すると動作は変更可能。
 * asyncやdeferを使わずに、HTMLの最後にscriptを置く方法もある。
 * 
 * ### 15.1.2 ドキュメントオブジェクトモデル(DOM)
 * HTMLドキュメントコンテンツを扱うためのAPIをDOMという。
 * DOM APIはHTMLドキュメントをミラーリングする。
 * DOM APIを使ってドキュメントツリーを組み立てたり操作したりすることでHTMLを出力できる。
 * 
 * ### 15.1.3 Webブラウザのグローバルオブジェクト
 * ブラウザのウィンドウやタブには１つずつグローバルオブジェクト(windowプロパティ)がある。
 * JavaScriptのコードは１つのグローバルオブジェクトを共有する。
 * グローバルオブジェクト(windowプロパティ)には２つの役割がある。
 * - 組み込み型や関数を定義する
 * - 現在のWebブラウザのウィンドウを表す
 * 
 * ### 15.1.4 名前空間を共有するスクリプト
 * - モジュール
 * トップレベルで定義された関数、クラス全てprivate。exportすると他から参照できる。
 * - モジュール以外のスクリプト
 * トップレベルで定義された関数、クラス全てpublic。ドキュメント中のスクリプトは１つの名前空間を共有する。
 * var, function宣言の場合、共有されるグローバルオブジェクトにプロパティ作成される。
 * const, let, class宣言の場合は、グローバルオブジェクトにプロパティは作成されないが、共有された名前空間で定義される。
 * 
 * ### 15.1.5 JavaScriptプログラムの実行方法
 * - 第一段階: ドキュメントの読み込み時
 * - 第二段階：非同期でのイベントドリブン
 * マウスクリック、キー入力、ネットワーク状態変化、ドキュメント・リソース読み込みなど
 * `DOMContentLoaded`イベント - HTMLドキュメントが完全に読み込まれ解析された時
 * `load`イベント - 画像などドキュメントのすべての外部リソースも完全に読み込まれた時
 * 
 * ### 15.1.5.1 クライアントサイドJavaScriptのスレッドモデル
 * Javascriptはシングルスレッドのプログラミング言語。
 * WebプラットフォームではWeb Workderという並列実行の仕組みがあり、バッググラウンドスレッドを立てることができる。
 * ただし、ワーカースレッドで実行されるコードはドキュメントのコンテンツへアクセス不可。
 * 
 * ### 15.1.5.2 クライアントサイド JavaScriptのタイムライン
 * 1. WebブラウザがDocumentオブジェクトを作成し、Webページの解析を開始。
 * HTML要素やテキストコンテンツを解析しながら、ドキュメントに対してElementやTextノードを追加。
 * `document.readyState`は`loading`。
 * 2. HTMLパーサーはasyncやdefer属性、type="module"属性を持たない`<script>`要素を見つけるとドキュメントにこの要素を追加。
 * その後、スクリプトを同期実行する。その間、HTMLパーサーは停止する。同期実行するスクリプトでは関数の定義とイベントハンドラへの登録のみするのが通常。
 * 3. HTMLパーサーはasync属性の`<script>`を見つけると、スクリプトのダウンロードを実行（スクリプトがモジュールんの場合は依存関係も再帰的にダウンロード）。
 * ダウンロード後にスクリプトはできるだけ早く実行されるが、パーサーは止めない。
 * 4. ドキュメントが完全に解析できたら、`document.readyState`は`interactive`になる。
 * 5. defer属性が設定されたスクリプト、async属性を持たないモジュールスクリプトは記述された順で実行される。
 * ドキュメントツリー全体にアクセスできる。
 * 6. ブラウザはDocumentオブジェクトに対して`DOMContentLoaded`イベントを発生。
 * 同期スクリプト実行段階から非同期イベントドリブン段階に移行。
 * 7. 画像や追加コンテンツの読み込みなどすべてのコンテンツの読み込みが完了して、すべてのasyncスクリプトが実行されたときに、`document.readyState`は`complete`に変わる。
 * ブラウザはWindowオブジェクトに対して`load`イベントを発生させる。
 * 8. ユーザー入力イベントやネットワークイベント、時刻の経過などに応じてイベントハンドラが非同期で呼び出される。
 * 
 * ### 15.1.6 プログラムの入力と出力
 * #### 入力データ
 * - ドキュメントのコンテンツ自身。JavaScriptコードからはDOM APIでアクセス。
 * - ユーザーの入力。`<button>`の押下や`<textarea>`への入力など
 * - ドキュメントのURL。`document.URL`でアクセス可能。
 * - HTTPのCookieリクエストヘッダの内容。`document.cookie`でアクセス可能。
 * - グローバルの`navigator`から、Webブラウザの情報や動作しているOS、その機能についての情報を得られる。
 *  - navigator.language - ユーザーの好みの言語
 *  - navigator.screen - ユーザーの画面サイズ
 * 
 * ### 15.1.7 プログラムエラー
 * OS上で直接実行されるアプリケーションとは異なり、Webブラウザ上のJavaScriptはクラッシュしない。
 * catchされない例外はコンソール出力され、登録済イベントハンドラは動作し続ける。
 * catchされない例外をエラーハンドラで処理したい場合は、`onerror(message, errorUrlString, errorLine)`を使う。
 * `onerror`がfalseを返すと、このイベントは処理されたとみなされてWeb開発者コンソールへの出力はされない。
 * `Promise`が失敗してcatchされない場合は`window.onunhandledrejection(promise, reason)`または`window.addEventListener("unhandledRejetion", () => {})`を用いる。
 * `preventDefault`を呼び出すと、このイベントは処理されたとみなされてWeb開発者コンソールへの出力はされない。
 * 
 * ### 15.1.8 Webのセキュリティモデル
 * #### 15.1.8.1 JavaScriptではできないこと
 * クライアントサイドJavaScriptではクライアント側のコンピュータ上のファイルの書込、削除、一覧取得はできない。
 * また、汎用的なネットワーク機能がない。
 * 
 * #### 15.1.8.2 同一オリジンポリシー
 * あるスクリプトはそのスクリプトを含むドキュメントと同じオリジンのウィンドウやドキュメントのプロパティしか読み出せない。
 * オリジンはURLのプロトコル、ホスト、ポート番号の組み合わせである。
 * 同一オリジンポリシーが適用されるのは下記の場合
 * - Webページに<iframe>要素が含まれる
 * 異なる<iframe>がある場合、ある<iframe>のドキュメントのスクリプトは他の<iframe>のドキュメントやウィンドウにアクセスできない。
 * - スクリプトから制御するHTTPリクエスト
 * スクリプト内で送信できるWebサーバーへのリクエストは同一オリジンのWebサーバーのみ。ただし、CORSを使った場合は制限が緩む。
 * 
 * 同一オリジンポリシーを緩和する方法
 * - `document.domain`を上位のサフィックスに変更する。（例： orders.example.com -> example.com）
 * - CORS(Cross-Origin Resource Sharing)を使用する。
 * サーバー側で情報を提供するオリジンを決定する。CORSでは、HTTPに対してOrigin:リクエストヘッダとAccessControl-Allow-Originレスポンスヘッダを拡張する。
 * このヘッダーを使って、サーバー側から明示的にファイル要求して良いオリジンを列挙する。（ワイルドカードも可能。）
 * 
 * #### 15.1.8.3 クロスサイトスクリプティング(XSS)
 * 攻撃者が攻撃対象のwebサイトに対してHTMLタグやスクリプトを注入すると発生するセキュリティ問題。
 * ユーザー入力を「サニタイズ（無害）」(HTMLタグの削除)をせずにそのまま使用してドキュメントのコンテンツを動的に作ると発生する。
 * 
 */
