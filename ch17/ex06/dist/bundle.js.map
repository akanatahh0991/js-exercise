{"version":3,"file":"bundle.js","mappings":"mBAAA,MACMA,EADSC,SAASC,cAAc,WACnBC,WAAW,MAGjBC,EAAa,GAMnB,SAASC,EAAWC,GACzB,IAAK,IAAIC,EAAM,EAAGA,EAAMD,EAAKE,OAAQD,IACnC,IAAK,IAAIE,EAAM,EAAGA,EAAMH,EAAKC,GAAKC,OAAQC,IAAO,CAC/C,MAAMC,EAAOJ,EAAKC,GAAKE,GACvBT,EAAIW,YACJX,EAAIY,KAAKH,EAAML,EAAYG,EAAMH,EAAYA,EAAYA,GACzDJ,EAAIa,UAAYH,EAAO,QAAU,QACjCV,EAAIc,OACJd,EAAIe,QACN,CAEJ,CCjBA,MAGM,EAASd,SAASC,cAAc,WAChCc,EAAcf,SAASC,cAAc,UACrCe,EAAchB,SAASC,cAAc,UAE3C,EAAOgB,MAAQC,IACf,EAAOC,OAASC,IAGhB,IAAIC,EAAc,KAGlB,MAAMC,EAAQ,IAAIC,MAAM,4BAGxB,IAAIlB,EAAO,IAAImB,MAjBF,IAkBVX,KAAK,MACLY,KAAI,IACH,IAAID,MAnBK,IAmBOX,KAAK,MAAMY,KAAI,MAAQC,KAAKC,MAAsB,EAAhBD,KAAKE,cAqB3D,SAASC,IACPxB,ECxCK,SAAoBA,GAEzB,MAAMyB,EAAWzB,EAAKoB,KAAKM,GAAQ,IAAIA,KAEvC,IAAK,IAAIzB,EAAM,EAAGA,EAAMD,EAAKE,OAAQD,IACnC,IAAK,IAAIE,EAAM,EAAGA,EAAMH,EAAKC,GAAKC,OAAQC,IAAO,CAE/C,IAAIwB,EAAQ,EACZ,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IACvB,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IACvB,GAAU,IAAND,GAAiB,IAANC,OAER,CACL,MAAMC,EAAe9B,EAAKC,EAAM2B,KAAKzB,EAAM0B,IACtB,IAAjBC,GACFH,GAEJ,CAGJ,MAAMI,EAAaN,EAASxB,GAAKE,IAC5B4B,GAAwB,IAAVJ,GAERI,IAAyB,IAAVJ,GAAyB,IAAVA,GADvCF,EAASxB,GAAKE,IAAO,GAGZ4B,GAAcJ,GAAS,GAEvBI,GAAcJ,GAAS,KADhCF,EAASxB,GAAKE,IAAO,EAMzB,CAEF,OAAOsB,CACT,CDKSO,CAAWhC,GAClBD,EAAWC,GACXgB,EAAciB,sBAAsBT,EACtC,CArBA,EAAOU,iBAAiB,SAAS,SAAUC,GACzC,MAAM7B,EAAO,EAAO8B,wBACdC,EAAWF,EAAIG,QAAUhC,EAAKiC,KAA9BF,EAAuCF,EAAIK,QAAUlC,EAAKmC,IAE1DxC,EAAMoB,KAAKC,MAAMe,EAAQvC,GACzBK,EAAMkB,KAAKC,MAAMe,EAAQvC,GAC/BE,EAAKC,GAAKE,IAAQH,EAAKC,GAAKE,GAC5Bc,EAAMyB,YAAYC,OAClB5C,EAAWC,EACb,IAcAU,EAAYwB,iBAAiB,SAAS,KAEhClB,GAGJQ,GAAQ,IAGVb,EAAYuB,iBAAiB,SAAS,KAE/BlB,IAGL4B,qBAAqB5B,GACrBA,EAAc,KAAI,IAGpBjB,EAAWC,E","sources":["webpack:///./renderGrid.js","webpack:///./index.js","webpack:///./updateGrid.js"],"sourcesContent":["const canvas = document.querySelector('#screen');\nconst ctx = canvas.getContext('2d');\n\n// 1セルのサイズ\nexport const RESOLUTION = 10;\n\n/**\n * `grid`をレンダリングする。\n * @param {Array<Array<boolean>>} grid グリッド\n */\nexport function renderGrid(grid) {\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      const cell = grid[row][col];\n      ctx.beginPath();\n      ctx.rect(col * RESOLUTION, row * RESOLUTION, RESOLUTION, RESOLUTION);\n      ctx.fillStyle = cell ? 'black' : 'white';\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n}\n","import { renderGrid, RESOLUTION } from './renderGrid.js';\nimport { updateGrid } from './updateGrid.js';\n\n// 50 x 50 の盤面とする\nconst ROWS = 50;\nconst COLS = 50;\n\nconst canvas = document.querySelector('#screen');\nconst startButton = document.querySelector('#start');\nconst pauseButton = document.querySelector('#pause');\n\ncanvas.width = ROWS * RESOLUTION;\ncanvas.height = COLS * RESOLUTION;\n\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame が返す ID\nlet animationId = null;\n\n// NOTE: download from https://soundeffect-lab.info/sound/button/mp3/decision1.mp3\nconst sound = new Audio('/ch17/ex06/decision1.mp3');\n\n// ライフゲームのセル (true or false) をランダムに初期化する\nlet grid = new Array(ROWS)\n  .fill(null)\n  .map(() =>\n    new Array(COLS).fill(null).map(() => !!Math.floor(Math.random() * 2))\n  );\n\n// canvas がクリックされたときの処理 (セルの値を反転する)\ncanvas.addEventListener('click', function (evt) {\n  const rect = canvas.getBoundingClientRect();\n  const pos = { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n\n  const row = Math.floor(pos.y / RESOLUTION);\n  const col = Math.floor(pos.x / RESOLUTION);\n  grid[row][col] = !grid[row][col];\n  sound.cloneNode().play();\n  renderGrid(grid);\n});\n\n// requestAnimationFrame によって一定間隔で更新・描画を行う\n// NOTE: リフレッシュレートの高い画面では速く実行される (これを防ぐ場合は下記の例を参照)\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame\n/**\n * updateする\n */\nfunction update() {\n  grid = updateGrid(grid);\n  renderGrid(grid);\n  animationId = requestAnimationFrame(update);\n}\n\nstartButton.addEventListener('click', () => {\n  // 既にアニメーションが動いている場合は何もしない\n  if (animationId) {\n    return;\n  }\n  update();\n});\n\npauseButton.addEventListener('click', () => {\n  // アニメーションが停止している場合は何もしない\n  if (!animationId) {\n    return;\n  }\n  cancelAnimationFrame(animationId);\n  animationId = null;\n});\n\nrenderGrid(grid);\n","// eslint-disable-next-line valid-jsdoc\n/**\n * グリッドを更新する\n * @param {Array<Array<boolean>>>} grid グリッド\n * @returns 新しいグリッド\n */\nexport function updateGrid(grid) {\n  // 新しいグリッドを作成\n  const nextGrid = grid.map((arr) => [...arr]);\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      // 周囲のセルの生存数を数えて nextGrid[row][col] に true or false を設定する (実装してね)\n      let alive = 0;\n      for (let i = -1; i <= 1; i++) {\n        for (let j = -1; j <= 1; j++) {\n          if (i === 0 && j === 0) {\n            // 何もしない\n          } else {\n            const adjacentCell = grid[row + i]?.[col + j];\n            if (adjacentCell === true) {\n              alive++;\n            }\n          }\n        }\n      }\n      const targetCell = nextGrid[row][col];\n      if (!targetCell && alive === 3) {\n        nextGrid[row][col] = true;\n      } else if (targetCell && (alive === 2 || alive === 3)) {\n        nextGrid[row][col] = true;\n      } else if (targetCell && alive <= 1) {\n        nextGrid[row][col] = false;\n      } else if (targetCell && alive >= 4) {\n        nextGrid[row][col] = false;\n      } else {\n        // 何もしない\n      }\n    }\n  }\n  return nextGrid;\n}\n"],"names":["ctx","document","querySelector","getContext","RESOLUTION","renderGrid","grid","row","length","col","cell","beginPath","rect","fillStyle","fill","stroke","startButton","pauseButton","width","ROWS","height","COLS","animationId","sound","Audio","Array","map","Math","floor","random","update","nextGrid","arr","alive","i","j","adjacentCell","targetCell","updateGrid","requestAnimationFrame","addEventListener","evt","getBoundingClientRect","pos","clientX","left","clientY","top","cloneNode","play","cancelAnimationFrame"],"sourceRoot":""}